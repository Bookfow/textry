'use client'

import { useState, useRef, useEffect, useCallback } from 'react'
import { pdfjs } from 'react-pdf'
import { ChevronLeft, ChevronRight, Minus, Plus, List, AlignLeft, AlignJustify, Settings2, Focus } from 'lucide-react'
import { supabase } from '@/lib/supabase'

pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`

interface ReflowViewerProps {
  pdfUrl: string
  documentId?: string
  pageNumber: number
  onPageChange?: (page: number, total: number) => void
  onDocumentLoad?: (numPages: number) => void
  onSwitchToPdf?: () => void
  fileType?: 'pdf' | 'epub'
  customToc?: { title: string }[] | null
}

// â”â”â” ë¦¬í”Œë¡œìš° ì„¤ì • â”â”â”
type ReflowFont = 'sans' | 'serif' | 'mono'
type ReflowTheme = 'light' | 'sepia' | 'dark'
type ReflowAlign = 'left' | 'justify'

const FONTS: Record<ReflowFont, { label: string; family: string }> = {
  sans: { label: 'ê³ ë”•', family: 'system-ui, -apple-system, "Noto Sans KR", sans-serif' },
  serif: { label: 'ëª…ì¡°', family: '"Noto Serif KR", "Batang", Georgia, serif' },
  mono: { label: 'ê³ ì •í­', family: '"Noto Sans Mono", "D2Coding", monospace' },
}

const THEMES: Record<ReflowTheme, { bg: string; text: string; muted: string; border: string; pageBg: string; headingColor: string }> = {
  light: { bg: '#FFFFFF', text: '#2D2016', muted: '#9C8B7A', border: '#E7D8C9', pageBg: '#F7F2EF', headingColor: '#2D2016' },
  sepia: { bg: '#f8f1e3', text: '#5b4636', muted: '#8b7355', border: '#d4c5a9', pageBg: '#ede4d3', headingColor: '#3d2b1f' },
  dark: { bg: '#241E18', text: '#EEE4E1', muted: '#9C8B7A', border: '#3A302A', pageBg: '#1A1410', headingColor: '#EEE4E1' },
}

// â”â”â” ê¹¨ì§„ í…ìŠ¤íŠ¸ ê°ì§€ â”â”â”
function isBrokenText(text: string): boolean {
  if (!text || text.trim().length === 0) return true
  const cleaned = text.replace(/\s/g, '')
  if (cleaned.length === 0) return true

  let meaningfulCount = 0
  for (let i = 0; i < cleaned.length; i++) {
    const code = cleaned.charCodeAt(i)
    if ((code >= 0xAC00 && code <= 0xD7AF) || (code >= 0x3131 && code <= 0x318E)) {
      meaningfulCount++
    } else if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A)) {
      meaningfulCount++
    }
  }
  if (cleaned.length >= 10 && meaningfulCount / cleaned.length < 0.15) return true
  if (cleaned.length >= 30 && meaningfulCount / cleaned.length < 0.25) return true

  let normalCount = 0
  for (let i = 0; i < cleaned.length; i++) {
    const code = cleaned.charCodeAt(i)
    if (
      (code >= 0xAC00 && code <= 0xD7AF) || (code >= 0x3131 && code <= 0x318E) ||
      (code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A) ||
      (code >= 0x0030 && code <= 0x0039) || (code >= 0x0020 && code <= 0x007E) ||
      (code >= 0x2000 && code <= 0x206F) || (code >= 0x3000 && code <= 0x303F) ||
      (code >= 0xFF01 && code <= 0xFF5E)
    ) normalCount++
  }
  if (cleaned.length >= 5 && normalCount / cleaned.length < 0.4) return true

  let brokenCount = 0
  for (let i = 0; i < cleaned.length; i++) {
    const code = cleaned.charCodeAt(i)
    if (
      (code >= 0xE000 && code <= 0xF8FF) ||
      (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) ||
      code === 0xFFFD || (code >= 0x2400 && code <= 0x243F)
    ) brokenCount++
  }
  if (brokenCount / cleaned.length > 0.3) return true
  if (/[â–¡â–¯â—‹â—»â—¼â– â–ªâ–«]{3,}/.test(cleaned)) return true
  if (/^[\d$&*%#@!^+=\/\\|<>.,;:'"(){}\[\]\-_~`]{8,}$/.test(cleaned)) return true

  return false
}

// â”â”â” HTML ì½˜í…ì¸  ê°ì§€ â”â”â”
function isHtmlContent(text: string): boolean {
  if (!text) return false
  // <p>, <p style=...>, <h1>~<h3>, <figure>, <strong> íƒœê·¸ê°€ ìˆìœ¼ë©´ HTML
  return /<(p|h[1-6]|figure|div|br|img|strong|em)[\s>/]/i.test(text)
}

// â”â”â” ë¸”ë¡ íƒ€ì… â”â”â”
type BlockType = 'heading1' | 'heading2' | 'heading3' | 'body' | 'separator'

interface TextBlock {
  type: BlockType
  content: string
}

// â”â”â” í°íŠ¸ í¬ê¸° ê¸°ë°˜ ë¸”ë¡ ë¶„ë¥˜ â”â”â”
function classifyBlocks(items: any[]): TextBlock[] {
  if (items.length === 0) return []

  interface LineInfo { text: string; fontSize: number; y: number }

  const lines: LineInfo[] = []
  let lastY: number | null = null
  let currentLine = ''
  let currentFontSizes: number[] = []
  let currentY = 0

  for (const item of items) {
    if (!('str' in item) || !item.str) continue
    const y = Math.round(item.transform[5])
    const fs = Math.round(Math.abs(item.transform[3]) || Math.abs(item.transform[0]) || 12)

    if (lastY !== null && Math.abs(y - lastY) > 3) {
      const trimmed = currentLine.trim()
      if (trimmed) {
        const avgFs = currentFontSizes.length > 0
          ? currentFontSizes.reduce((a, b) => a + b, 0) / currentFontSizes.length : 12
        lines.push({ text: trimmed, fontSize: Math.round(avgFs), y: currentY })
      }
      currentLine = ''
      currentFontSizes = []
    }

    currentLine += item.str
    currentFontSizes.push(fs)
    currentY = y
    lastY = y
  }

  const trimmedLast = currentLine.trim()
  if (trimmedLast) {
    const avgFs = currentFontSizes.length > 0
      ? currentFontSizes.reduce((a, b) => a + b, 0) / currentFontSizes.length : 12
    lines.push({ text: trimmedLast, fontSize: Math.round(avgFs), y: currentY })
  }

  if (lines.length === 0) return []

  const cleanLines = lines.filter(l => !isBrokenText(l.text))
  if (cleanLines.length === 0) return [{ type: 'body', content: '(í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤)' }]

  const fsCount = new Map<number, number>()
  for (const l of cleanLines) fsCount.set(l.fontSize, (fsCount.get(l.fontSize) || 0) + l.text.length)
  let bodyFontSize = 12
  let maxWeight = 0
  for (const [fs, weight] of fsCount) { if (weight > maxWeight) { maxWeight = weight; bodyFontSize = fs } }

  const blocks: TextBlock[] = []
  let currentParagraph = ''
  let lastLineY: number | null = null
  const avgLineGap = cleanLines.length > 1
    ? cleanLines.slice(1).reduce((sum, l, i) => sum + Math.abs(l.y - cleanLines[i].y), 0) / (cleanLines.length - 1) : 20

  for (let i = 0; i < cleanLines.length; i++) {
    const line = cleanLines[i]
    const fsDiff = line.fontSize - bodyFontSize

    if (lastLineY !== null) {
      const gap = Math.abs(line.y - lastLineY)
      if (gap > avgLineGap * 2.5 && currentParagraph) {
        blocks.push({ type: 'body', content: currentParagraph })
        currentParagraph = ''
        blocks.push({ type: 'separator', content: '' })
      }
    }

    if (fsDiff >= 4 && line.text.length < 80) {
      if (currentParagraph) { blocks.push({ type: 'body', content: currentParagraph }); currentParagraph = '' }
      if (fsDiff >= 8) blocks.push({ type: 'heading1', content: line.text })
      else blocks.push({ type: 'heading2', content: line.text })
    } else if (fsDiff >= 2 && line.text.length < 50) {
      if (currentParagraph) { blocks.push({ type: 'body', content: currentParagraph }); currentParagraph = '' }
      blocks.push({ type: 'heading3', content: line.text })
    } else {
      if (currentParagraph) currentParagraph += ' '
      currentParagraph += line.text
    }
    lastLineY = line.y
  }

  if (currentParagraph) blocks.push({ type: 'body', content: currentParagraph })
  return blocks
}

// â”â”â” ë¸”ë¡ â†” ì§ë ¬í™” â”â”â”
function serializeBlocks(blocks: TextBlock[]): string {
  return blocks.map(b => {
    switch (b.type) {
      case 'heading1': return `<h1>${b.content}</h1>`
      case 'heading2': return `<h2>${b.content}</h2>`
      case 'heading3': return `<h3>${b.content}</h3>`
      case 'separator': return '<hr>'
      default: return b.content
    }
  }).join('\n\n')
}

function deserializeBlocks(text: string): TextBlock[] {
  if (!text) return []
  const parts = text.split('\n\n')
  return parts.map(part => {
    if (part.startsWith('<h1>') && part.endsWith('</h1>')) return { type: 'heading1' as BlockType, content: part.slice(4, -5) }
    if (part.startsWith('<h2>') && part.endsWith('</h2>')) return { type: 'heading2' as BlockType, content: part.slice(4, -5) }
    if (part.startsWith('<h3>') && part.endsWith('</h3>')) return { type: 'heading3' as BlockType, content: part.slice(4, -5) }
    if (part === '<hr>') return { type: 'separator' as BlockType, content: '' }
    return { type: 'body' as BlockType, content: part }
  }).filter(b => b.content || b.type === 'separator')
}

export default function ReflowViewer({
  pdfUrl,
  documentId,
  pageNumber,
  onPageChange,
  onDocumentLoad,
  onSwitchToPdf,
  fileType = 'pdf',
  customToc,
}: ReflowViewerProps) {
  const [pageTexts, setPageTexts] = useState<Map<number, string>>(new Map())
  const [numPages, setNumPages] = useState(0)
  const [extracting, setExtracting] = useState(true)
  const [extractProgress, setExtractProgress] = useState(0)
  const [loadSource, setLoadSource] = useState<'db' | 'client' | ''>('')
  const [unsupported, setUnsupported] = useState(false)

  const isEpub = fileType === 'epub'

  const [fontSize, setFontSize] = useState(18)
  const [lineHeight, setLineHeight] = useState(1.8)
  const [font, setFont] = useState<ReflowFont>('sans')
  const [theme, setTheme] = useState<ReflowTheme>('dark')
  const [showSettings, setShowSettings] = useState(false)

  const [marginSize, setMarginSize] = useState(2)
  const [letterSpacing, setLetterSpacing] = useState(0)
  const [textAlign, setTextAlign] = useState<ReflowAlign>('left')
  const [showToc, setShowToc] = useState(false)
  const [slideDirection, setSlideDirection] = useState<'left' | 'right' | ''>('')

  // â˜… ì§‘ì¤‘ ëª¨ë“œ (ë¬¸ë‹¨ í¬ì»¤ìŠ¤)
  const [focusMode, setFocusMode] = useState(false)
  const [focusedBlock, setFocusedBlock] = useState<number | null>(null)

  // â˜… ë‚¨ì€ ì‹œê°„ í‘œì‹œ
  const [elapsedSec, setElapsedSec] = useState(0)
  const elapsedRef = useRef(0)

  const touchStartRef = useRef<{ x: number; y: number } | null>(null)
  const touchEndRef = useRef<{ x: number; y: number } | null>(null)
  const contentRef = useRef<HTMLDivElement>(null)

  // â˜… ë‚¨ì€ ì‹œê°„ìš© ê²½ê³¼ ì‹œê°„ íƒ€ì´ë¨¸
  useEffect(() => {
    const timer = setInterval(() => {
      elapsedRef.current += 10
      setElapsedSec(elapsedRef.current)
    }, 10000)
    return () => clearInterval(timer)
  }, [])

  // â”â”â” localStorage ë³µì› â”â”â”
  useEffect(() => {
    try {
      const saved = localStorage.getItem('textry_reflow_settings')
      if (saved) {
        const s = JSON.parse(saved)
        if (s.fontSize) setFontSize(s.fontSize)
        if (s.lineHeight) setLineHeight(s.lineHeight)
        if (s.font) setFont(s.font)
        if (s.theme) setTheme(s.theme)
        if (s.marginSize) setMarginSize(s.marginSize)
        if (s.letterSpacing !== undefined) setLetterSpacing(s.letterSpacing)
        if (s.textAlign) setTextAlign(s.textAlign)
        if (s.focusMode !== undefined) setFocusMode(s.focusMode)
      }
    } catch {}
  }, [])

  useEffect(() => {
    try {
      localStorage.setItem('textry_reflow_settings', JSON.stringify({ fontSize, lineHeight, font, theme, marginSize, letterSpacing, textAlign, focusMode }))
    } catch {}
  }, [fontSize, lineHeight, font, theme, marginSize, letterSpacing, textAlign])

  // â”â”â” DB ìš°ì„  ì¡°íšŒ â†’ í´ë¼ì´ì–¸íŠ¸ ì¶”ì¶œ fallback â”â”â”
  useEffect(() => {
    if (!isEpub && !pdfUrl) return
    if (isEpub && !documentId) return
    let cancelled = false

    const loadTexts = async () => {
      setExtracting(true)
      setExtractProgress(0)
      setLoadSource('')

      if (documentId) {
        try {
          const { data, error } = await supabase
            .from('document_pages_text')
            .select('page_number, text_content')
            .eq('document_id', documentId)
            .order('page_number', { ascending: true })

          if (!error && data && data.length > 0) {
            const texts = new Map<number, string>()
            const total = data.length

            for (const row of data) {
              texts.set(row.page_number, row.text_content || `(${row.page_number}í˜ì´ì§€: í…ìŠ¤íŠ¸ ì—†ìŒ)`)
            }

            if (!cancelled) {
              setPageTexts(texts)
              setNumPages(total)
              setLoadSource('db')
              setExtracting(false)
              setExtractProgress(100)
              if (onDocumentLoad) onDocumentLoad(total)

              if (!isEpub) {
                let emptyCount = 0
                for (const [, t] of texts) {
                  const cleaned = t.replace(/<h[1-3]>.*?<\/h[1-3]>|<hr>/g, '').replace(/\s/g, '')
                  if (cleaned.length < 10) { emptyCount++; continue }
                  let mc = 0
                  for (let i = 0; i < cleaned.length; i++) {
                    const c = cleaned.charCodeAt(i)
                    if ((c >= 0xAC00 && c <= 0xD7AF) || (c >= 0x3131 && c <= 0x318E) ||
                        (c >= 0x0041 && c <= 0x005A) || (c >= 0x0061 && c <= 0x007A)) mc++
                  }
                  if (cleaned.length < 20 && mc < 5) emptyCount++
                }
                if (total > 0 && emptyCount / total > 0.5) setUnsupported(true)
              }
            }
            return
          }
        } catch (dbErr) {
          console.warn('DB í…ìŠ¤íŠ¸ ì¡°íšŒ ì‹¤íŒ¨, í´ë¼ì´ì–¸íŠ¸ ì¶”ì¶œë¡œ ì „í™˜:', dbErr)
        }
      }

      if (isEpub) {
        if (!cancelled) {
          setExtracting(false)
          setUnsupported(true)
        }
        return
      }

      if (cancelled) return
      setLoadSource('client')

      try {
        const loadingTask = pdfjs.getDocument({
          url: pdfUrl,
          cMapUrl: `//unpkg.com/pdfjs-dist@${pdfjs.version}/cmaps/`,
          cMapPacked: true,
        })
        const pdf = await loadingTask.promise
        const total = pdf.numPages
        setNumPages(total)
        if (onDocumentLoad) onDocumentLoad(total)

        let scanPageCount = 0
        const checkPages = Math.min(3, total)
        for (let i = 1; i <= checkPages; i++) {
          if (cancelled) return
          const page = await pdf.getPage(i)
          const ops = await page.getOperatorList()
          let hasImage = false
          let textOpCount = 0
          for (let j = 0; j < ops.fnArray.length; j++) {
            const fn = ops.fnArray[j]
            if (fn === 85 || fn === 82) hasImage = true
            if (fn === 44 || fn === 45) textOpCount++
          }
          if (hasImage && textOpCount < 5) scanPageCount++
        }

        if (scanPageCount >= checkPages) {
          if (!cancelled) {
            const texts = new Map<number, string>()
            for (let i = 1; i <= total; i++) {
              texts.set(i, `(${i}í˜ì´ì§€: ìŠ¤ìº” ì´ë¯¸ì§€)`)
            }
            setPageTexts(texts)
            setNumPages(total)
            setExtracting(false)
            setExtractProgress(100)
            setUnsupported(true)
          }
          return
        }

        const texts = new Map<number, string>()

        for (let i = 1; i <= total; i++) {
          if (cancelled) return
          const page = await pdf.getPage(i)
          const textContent = await page.getTextContent()
          const blocks = classifyBlocks(textContent.items as any[])
          const serialized = serializeBlocks(blocks)
          texts.set(i, serialized || `(${i}í˜ì´ì§€: í…ìŠ¤íŠ¸ ì—†ìŒ)`)
          setExtractProgress(Math.round((i / total) * 100))
        }

        if (!cancelled) {
          setPageTexts(texts)
          setExtracting(false)

          let emptyCount = 0
          for (const [, t] of texts) {
            const cleaned = t.replace(/<h[1-3]>.*?<\/h[1-3]>|<hr>/g, '').replace(/\s/g, '')
            if (cleaned.length < 10) { emptyCount++; continue }
            let mc = 0
            for (let i = 0; i < cleaned.length; i++) {
              const c = cleaned.charCodeAt(i)
              if ((c >= 0xAC00 && c <= 0xD7AF) || (c >= 0x3131 && c <= 0x318E) ||
                  (c >= 0x0041 && c <= 0x005A) || (c >= 0x0061 && c <= 0x007A)) mc++
            }
            if (cleaned.length < 20 && mc < 5) emptyCount++
          }
          if (total > 0 && emptyCount / total > 0.5) setUnsupported(true)
        }
      } catch (err) {
        console.error('Text extraction error:', err)
        if (!cancelled) setExtracting(false)
      }
    }

    loadTexts()
    return () => { cancelled = true }
  }, [pdfUrl, documentId, isEpub])

  const currentBlocks = deserializeBlocks(pageTexts.get(pageNumber) || '')

  const isCurrentPageBroken = (() => {
    if (isEpub) return false
    const raw = pageTexts.get(pageNumber) || ''
    const cleaned = raw.replace(/<h[1-3]>.*?<\/h[1-3]>|<hr>/g, '').replace(/\s/g, '')
    if (cleaned.length < 5) return true
    const allText = currentBlocks
      .filter(b => b.type !== 'separator')
      .map(b => b.content)
      .join('')
      .replace(/\s/g, '')
    let meaningfulCount = 0
    for (let i = 0; i < allText.length; i++) {
      const code = allText.charCodeAt(i)
      if ((code >= 0xAC00 && code <= 0xD7AF) || (code >= 0x3131 && code <= 0x318E) ||
          (code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A)) {
        meaningfulCount++
      }
    }
    if (allText.length > 0 && allText.length < 20 && meaningfulCount < 5) return true
    return false
  })()

  // â”â”â” í˜ì´ì§€ ì´ë™ â”â”â”
  const goToPrev = useCallback(() => {
    if (pageNumber > 1 && onPageChange) {
      setSlideDirection('right')
      onPageChange(pageNumber - 1, numPages)
    }
  }, [pageNumber, numPages, onPageChange])

  const goToNext = useCallback(() => {
    if (pageNumber < numPages && onPageChange) {
      setSlideDirection('left')
      onPageChange(pageNumber + 1, numPages)
    }
  }, [pageNumber, numPages, onPageChange])

  const goToPage = useCallback((page: number) => {
    const p = Math.max(1, Math.min(page, numPages))
    if (onPageChange) onPageChange(p, numPages)
  }, [numPages, onPageChange])

  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY }
    touchEndRef.current = null
  }

  const handleTouchMove = (e: React.TouchEvent) => {
    touchEndRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY }
  }

  const handleTouchEnd = () => {
    const ts = touchStartRef.current
    const te = touchEndRef.current
    if (!ts || !te) return
    const dx = ts.x - te.x
    const dy = Math.abs(ts.y - te.y)
    if (Math.abs(dx) > 50 && dy < Math.abs(dx)) {
      if (dx > 0) goToNext()
      else goToPrev()
    }
    touchStartRef.current = null
    touchEndRef.current = null
  }

  useEffect(() => {
    if (contentRef.current) {
      contentRef.current.scrollTop = 0
      setFocusedBlock(null)
      if (slideDirection) {
        const el = contentRef.current
        el.style.transition = 'none'
        el.style.transform = slideDirection === 'left' ? 'translateX(60px)' : 'translateX(-60px)'
        el.style.opacity = '0'
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            el.style.transition = 'transform 0.25s ease-out, opacity 0.25s ease-out'
            el.style.transform = 'translateX(0)'
            el.style.opacity = '1'
          })
        })
        setSlideDirection('')
      }
    }
  }, [pageNumber, slideDirection])

  const handleClick = (e: React.MouseEvent) => {
    if (showSettings) return
    // ì§‘ì¤‘ ëª¨ë“œì—ì„œ ë¹ˆ ì˜ì—­ í´ë¦­ ì‹œ í¬ì»¤ìŠ¤ í•´ì œ
    if (focusMode) { setFocusedBlock(null); return }
    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect()
    const clickX = e.clientX - rect.left
    if (clickX < rect.width / 2) goToPrev()
    else goToNext()
  }

  const themeStyle = THEMES[theme]
  const fontStyle = FONTS[font]
  const pageLabel = isEpub ? 'ì±•í„°' : 'í˜ì´ì§€'

  if (extracting) {
    return (
      <div className="h-full flex items-center justify-center" style={{ backgroundColor: themeStyle.pageBg }}>
        <div className="text-center">
          <div className="w-10 h-10 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-3" />
          <p style={{ color: themeStyle.muted }} className="text-sm">
            {isEpub
              ? 'EPUB ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...'
              : loadSource === 'client'
                ? `í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘... ${extractProgress}%`
                : 'í…ìŠ¤íŠ¸ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...'
            }
          </p>
          {loadSource === 'client' && !isEpub && (
            <div className="w-48 h-1.5 rounded-full mt-2 mx-auto overflow-hidden" style={{ backgroundColor: themeStyle.border }}>
              <div className="h-full bg-blue-500 rounded-full transition-all duration-300" style={{ width: `${extractProgress}%` }} />
            </div>
          )}
        </div>
      </div>
    )
  }

  // â”â”â” ë¸”ë¡ ë Œë”ë§ â”â”â”
  // â˜… ì§‘ì¤‘ ëª¨ë“œ: ë¸”ë¡ë³„ opacity ê³„ì‚°
  const getBlockOpacity = (index: number): number => {
    if (!focusMode) return 1
    if (focusedBlock === null) return 0.35
    if (index === focusedBlock) return 1
    const distance = Math.abs(index - focusedBlock)
    if (distance === 1) return 0.25
    return 0.12
  }

  const handleBlockClick = (index: number, e: React.MouseEvent) => {
    if (!focusMode) return
    e.stopPropagation()
    setFocusedBlock(prev => prev === index ? null : index)
  }

  const renderBlock = (block: TextBlock, index: number) => {
    const opacity = getBlockOpacity(index)
    const focusTransition = focusMode ? 'opacity 0.3s ease, transform 0.3s ease' : 'none'
    const focusScale = focusMode && focusedBlock === index ? 'scale(1.005)' : 'scale(1)'
    const focusCursor = focusMode ? 'cursor-pointer' : ''

    switch (block.type) {
      case 'heading1':
        return (
          <h2 key={index} className={`font-bold mt-10 mb-4 ${focusCursor}`}
            onClick={(e) => handleBlockClick(index, e)}
            style={{ fontSize: `${Math.round(fontSize * 1.6)}px`, lineHeight: 1.3, color: themeStyle.headingColor, fontFamily: fontStyle.family, letterSpacing: `${letterSpacing * 0.5}px`, opacity, transition: focusTransition, transform: focusScale }}>
            {block.content}
          </h2>
        )
      case 'heading2':
        return (
          <h3 key={index} className={`font-bold mt-8 mb-3 ${focusCursor}`}
            onClick={(e) => handleBlockClick(index, e)}
            style={{ fontSize: `${Math.round(fontSize * 1.35)}px`, lineHeight: 1.35, color: themeStyle.headingColor, fontFamily: fontStyle.family, letterSpacing: `${letterSpacing * 0.5}px`, opacity, transition: focusTransition, transform: focusScale }}>
            {block.content}
          </h3>
        )
      case 'heading3':
        return (
          <h4 key={index} className={`font-semibold mt-6 mb-2 ${focusCursor}`}
            onClick={(e) => handleBlockClick(index, e)}
            style={{ fontSize: `${Math.round(fontSize * 1.15)}px`, lineHeight: 1.4, color: themeStyle.headingColor, fontFamily: fontStyle.family, letterSpacing: `${letterSpacing * 0.5}px`, opacity, transition: focusTransition, transform: focusScale }}>
            {block.content}
          </h4>
        )
      case 'separator':
        return <div key={index} className="my-6" style={{ borderTop: `1px solid ${themeStyle.border}`, opacity, transition: focusTransition }} />
      default:
        return (
          <p key={index} className={`mb-4 ${focusCursor}`}
            onClick={(e) => handleBlockClick(index, e)}
            style={{ textIndent: '1em', fontFamily: fontStyle.family, fontSize: `${fontSize}px`, lineHeight: lineHeight, color: themeStyle.text, wordBreak: 'keep-all', overflowWrap: 'break-word', letterSpacing: `${letterSpacing * 0.5}px`, textAlign: textAlign, opacity, transition: focusTransition, transform: focusScale }}>
            {block.content}
          </p>
        )
    }
  }

  // â”â”â” ëª©ì°¨(TOC) â€” customToc ìš°ì„ , ì—†ìœ¼ë©´ ìë™ ì¶”ì¶œ â”â”â”
  const tocItems = (() => {
    // ìˆ˜ë™ ëª©ì°¨ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš© (í˜ì´ì§€ ë²ˆí˜¸ ì—†ì´ ì œëª©ë§Œ)
    if (customToc && customToc.length > 0) {
      return customToc.map((item, i) => ({ page: i + 1, title: item.title }))
    }
    // ìë™ ì¶”ì¶œ í´ë°±
    const items: { page: number; title: string }[] = []
    for (const [page, text] of pageTexts) {
      const h1Match = text.match(/<h1>(.*?)<\/h1>/)
      const h2Match = text.match(/<h2>(.*?)<\/h2>/)
      const title = h1Match?.[1] || h2Match?.[1]
      if (title && title.trim().length > 0) {
        items.push({ page, title: title.trim() })
      } else {
        const plainText = text.replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim()
        if (plainText.length > 0) {
          items.push({ page, title: plainText.slice(0, 40) + (plainText.length > 40 ? '...' : '') })
        }
      }
    }
    return items
  })()

  // â”â”â” ì—¬ë°± í¬ê¸° ë§¤í•‘ â”â”â”
  const MARGIN_MAP: Record<number, { maxW: string; px: string; label: string }> = {
    1: { maxW: '56rem', px: 'px-3 sm:px-4', label: 'ì¢ê²Œ' },
    2: { maxW: '42rem', px: 'px-6 sm:px-10', label: 'ë³´í†µ' },
    3: { maxW: '36rem', px: 'px-8 sm:px-14', label: 'ë„“ê²Œ' },
    4: { maxW: '28rem', px: 'px-10 sm:px-16', label: 'ì•„ì£¼ ë„“ê²Œ' },
  }
  const currentMargin = MARGIN_MAP[marginSize] || MARGIN_MAP[2]

  return (
    <div className="h-full flex flex-col" style={{ backgroundColor: themeStyle.pageBg }}>
      {/* â”â”â” TOC ì‚¬ì´ë“œ íŒ¨ë„ â”â”â” */}
      {showToc && (
        <div className="fixed inset-0 z-[60] flex">
          <div className="absolute inset-0 bg-black/40" onClick={() => setShowToc(false)} />
          <div className="relative w-72 max-w-[80vw] h-full flex flex-col shadow-2xl" style={{ backgroundColor: themeStyle.bg }}>
            <div className="flex items-center justify-between px-4 py-3 border-b" style={{ borderColor: themeStyle.border }}>
              <h3 className="font-semibold text-sm" style={{ color: themeStyle.headingColor }}>ëª©ì°¨</h3>
              <button onClick={() => setShowToc(false)} className="p-1 rounded hover:opacity-70" style={{ color: themeStyle.muted }}>âœ•</button>
            </div>
            <div className="flex-1 overflow-y-auto">
              {tocItems.length > 0 ? tocItems.map((item, i) => (
                <button key={i} onClick={() => { goToPage(item.page); setShowToc(false) }}
                  className={`w-full text-left px-4 py-3 border-b text-sm transition-colors ${
                    item.page === pageNumber ? 'font-semibold' : 'hover:opacity-80'
                  }`}
                  style={{
                    borderColor: themeStyle.border,
                    color: item.page === pageNumber ? '#3b82f6' : themeStyle.text,
                    backgroundColor: item.page === pageNumber
                      ? (theme === 'dark' ? 'rgba(59,130,246,0.1)' : 'rgba(59,130,246,0.05)')
                      : 'transparent',
                  }}>
                  <span className="text-xs mr-2" style={{ color: themeStyle.muted }}>{item.page}</span>
                  {item.title}
                </button>
              )) : (
                <p className="px-4 py-8 text-center text-sm" style={{ color: themeStyle.muted }}>ëª©ì°¨ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤</p>
              )}
            </div>
          </div>
        </div>
      )}

      {/* â”â”â” ë¯¸ë‹ˆë©€ ìƒë‹¨ ë°” â”â”â” */}
      <div className="grid grid-cols-4 px-2 py-2 border-b max-w-lg mx-auto w-full" style={{ borderColor: themeStyle.border }}>
        <button onClick={() => setShowToc(!showToc)}
          className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg transition-opacity hover:opacity-70"
          style={{ color: showToc ? '#3b82f6' : themeStyle.muted }}>
          <List className="w-4 h-4" />
          <span className="text-xs">ëª©ì°¨</span>
        </button>

        <button onClick={() => { setFocusMode(!focusMode); if (focusMode) setFocusedBlock(null) }}
          className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg transition-all"
          style={{
            color: focusMode ? '#3b82f6' : themeStyle.muted,
            backgroundColor: focusMode ? 'rgba(59,130,246,0.1)' : 'transparent',
          }}
          title="ì§‘ì¤‘ ëª¨ë“œ">
          <Focus className="w-4 h-4" />
          <span className="text-xs">ì§‘ì¤‘</span>
        </button>

        <div className="flex items-center justify-center">
          <span className="text-xs font-medium" style={{ color: themeStyle.muted }}>
            {pageNumber} / {numPages} {pageLabel}
          </span>
        </div>

        <button onClick={() => setShowSettings(!showSettings)}
          className="flex items-center justify-center gap-1.5 py-1.5 rounded-lg transition-opacity hover:opacity-70"
          style={{ color: showSettings ? '#3b82f6' : themeStyle.muted }}>
          <Settings2 className="w-4 h-4" />
          <span className="text-xs">ì„¤ì •</span>
        </button>
      </div>

      {/* â”â”â” ì„¤ì • ë°”í…€ ì‹œíŠ¸ â”â”â” */}
      {showSettings && (
        <>
          <div className="fixed inset-0 z-[55]" onClick={() => setShowSettings(false)} />
          <div className="fixed bottom-0 left-1/2 -translate-x-1/2 z-[56] rounded-t-2xl shadow-2xl max-h-[70vh] overflow-y-auto w-full max-w-lg"
            style={{ backgroundColor: theme === 'dark' ? 'rgba(36,30,24,0.85)' : theme === 'sepia' ? 'rgba(248,241,227,0.85)' : 'rgba(255,255,255,0.85)', backdropFilter: 'blur(8px)', WebkitBackdropFilter: 'blur(8px)', borderTop: `1px solid ${themeStyle.border}` }}>
            <div className="flex justify-center pt-3 pb-1">
              <div className="w-10 h-1 rounded-full" style={{ backgroundColor: themeStyle.border }} />
            </div>
            <div className="px-5 pb-6 space-y-5">

              {/* ë°°ê²½ í…Œë§ˆ */}
              <div>
                <p className="text-xs font-medium mb-3" style={{ color: themeStyle.muted }}>ë°°ê²½ í…Œë§ˆ</p>
                <div className="flex gap-3 justify-center">
                  {(Object.keys(THEMES) as ReflowTheme[]).map((t) => (
                    <button key={t} onClick={() => setTheme(t)} className="flex flex-col items-center gap-1.5">
                      <div className={`w-12 h-12 rounded-xl border-2 transition-all ${theme === t ? 'ring-2 ring-blue-500 ring-offset-2' : ''}`}
                        style={{ backgroundColor: THEMES[t].bg, borderColor: THEMES[t].border }} />
                      <span className="text-[10px]" style={{ color: theme === t ? '#3b82f6' : themeStyle.muted }}>
                        {t === 'light' ? 'ë°ì€' : t === 'sepia' ? 'ì„¸í”¼ì•„' : 'ì–´ë‘ìš´'}
                      </span>
                    </button>
                  ))}
                </div>
              </div>

              {/* ê¸€ê¼´ */}
              <div>
                <p className="text-xs font-medium mb-3" style={{ color: themeStyle.muted }}>ê¸€ê¼´</p>
                <div className="flex gap-2">
                  {(Object.keys(FONTS) as ReflowFont[]).map((f) => (
                    <button key={f} onClick={() => setFont(f)}
                      className={`flex-1 py-2 rounded-xl text-sm transition-all border ${font === f ? 'border-blue-500' : ''}`}
                      style={{
                        backgroundColor: font === f ? 'rgba(59,130,246,0.1)' : 'transparent',
                        borderColor: font === f ? '#3b82f6' : themeStyle.border,
                        color: font === f ? '#3b82f6' : themeStyle.text,
                        fontFamily: FONTS[f].family,
                      }}>
                      {FONTS[f].label}
                    </button>
                  ))}
                </div>
              </div>

              {/* ê¸€ì í¬ê¸° */}
              <div>
                <div className="flex items-center justify-between mb-3">
                  <p className="text-xs font-medium" style={{ color: themeStyle.muted }}>ê¸€ì í¬ê¸°</p>
                  <span className="text-xs font-mono" style={{ color: themeStyle.text }}>{fontSize}px</span>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setFontSize(s => Math.max(12, s - 1))}
                    className="w-9 h-9 rounded-xl flex items-center justify-center border transition-colors"
                    style={{ borderColor: themeStyle.border, color: themeStyle.muted }}>
                    <Minus className="w-4 h-4" />
                  </button>
                  <input type="range" min={12} max={32} value={fontSize} onChange={(e) => setFontSize(Number(e.target.value))}
                    className="flex-1 h-1.5 rounded-full appearance-none cursor-pointer accent-blue-500"
                    style={{ backgroundColor: themeStyle.border }} />
                  <button onClick={() => setFontSize(s => Math.min(32, s + 1))}
                    className="w-9 h-9 rounded-xl flex items-center justify-center border transition-colors"
                    style={{ borderColor: themeStyle.border, color: themeStyle.muted }}>
                    <Plus className="w-4 h-4" />
                  </button>
                </div>
              </div>

              {/* ì¤„ê°„ê²© */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <p className="text-xs font-medium" style={{ color: themeStyle.muted }}>ì¤„ê°„ê²©</p>
                  <span className="text-xs font-mono" style={{ color: themeStyle.text }}>{lineHeight.toFixed(1)}</span>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setLineHeight(h => Math.max(1.2, Math.round((h - 0.1) * 10) / 10))}
                    className="w-9 h-9 rounded-xl flex items-center justify-center border transition-colors"
                    style={{ borderColor: themeStyle.border, color: themeStyle.muted }}>
                    <Minus className="w-4 h-4" />
                  </button>
                  <input type="range" min={1.2} max={2.4} step={0.1} value={lineHeight}
                    onChange={(e) => setLineHeight(Number(e.target.value))}
                    className="flex-1 h-1.5 rounded-full appearance-none cursor-pointer accent-blue-500"
                    style={{ backgroundColor: themeStyle.border }} />
                  <button onClick={() => setLineHeight(h => Math.min(2.4, Math.round((h + 0.1) * 10) / 10))}
                    className="w-9 h-9 rounded-xl flex items-center justify-center border transition-colors"
                    style={{ borderColor: themeStyle.border, color: themeStyle.muted }}>
                    <Plus className="w-4 h-4" />
                  </button>
                </div>
              </div>

              {/* ì—¬ë°± Â· ìê°„ */}
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <div className="flex items-center justify-between mb-2">
                    <p className="text-[10px] font-medium" style={{ color: themeStyle.muted }}>ì—¬ë°±</p>
                    <span className="text-[10px]" style={{ color: themeStyle.text }}>
                      {marginSize === 1 ? 'ì¢ê²Œ' : marginSize === 2 ? 'ë³´í†µ' : marginSize === 3 ? 'ë„“ê²Œ' : 'ì•„ì£¼ ë„“ê²Œ'}
                    </span>
                  </div>
                  <input type="range" min={1} max={4} step={1} value={marginSize}
                    onChange={(e) => setMarginSize(Number(e.target.value))}
                    className="w-full h-1.5 rounded-full appearance-none cursor-pointer accent-blue-500"
                    style={{ backgroundColor: themeStyle.border }} />
                </div>
                <div>
                  <div className="flex items-center justify-between mb-2">
                    <p className="text-[10px] font-medium" style={{ color: themeStyle.muted }}>ìê°„</p>
                    <span className="text-[10px]" style={{ color: themeStyle.text }}>
                      {letterSpacing === -1 ? 'ì¢ê²Œ' : letterSpacing === 0 ? 'ë³´í†µ' : letterSpacing === 1 ? 'ë„“ê²Œ' : 'ì•„ì£¼ ë„“ê²Œ'}
                    </span>
                  </div>
                  <input type="range" min={-1} max={2} step={1} value={letterSpacing}
                    onChange={(e) => setLetterSpacing(Number(e.target.value))}
                    className="w-full h-1.5 rounded-full appearance-none cursor-pointer accent-blue-500"
                    style={{ backgroundColor: themeStyle.border }} />
                </div>
              </div>

              {/* ì •ë ¬ */}
              <div>
                <p className="text-xs font-medium mb-3" style={{ color: themeStyle.muted }}>ì •ë ¬</p>
                <div className="flex gap-2">
                  <button onClick={() => setTextAlign('left')}
                    className={`flex-1 py-2.5 rounded-xl text-xs flex items-center justify-center gap-2 border transition-all ${textAlign === 'left' ? 'border-blue-500' : ''}`}
                    style={{
                      backgroundColor: textAlign === 'left' ? 'rgba(59,130,246,0.1)' : 'transparent',
                      borderColor: textAlign === 'left' ? '#3b82f6' : themeStyle.border,
                      color: textAlign === 'left' ? '#3b82f6' : themeStyle.text,
                    }}>
                    <AlignLeft className="w-4 h-4" /> ì™¼ìª½
                  </button>
                  <button onClick={() => setTextAlign('justify')}
                    className={`flex-1 py-2.5 rounded-xl text-xs flex items-center justify-center gap-2 border transition-all ${textAlign === 'justify' ? 'border-blue-500' : ''}`}
                    style={{
                      backgroundColor: textAlign === 'justify' ? 'rgba(59,130,246,0.1)' : 'transparent',
                      borderColor: textAlign === 'justify' ? '#3b82f6' : themeStyle.border,
                      color: textAlign === 'justify' ? '#3b82f6' : themeStyle.text,
                    }}>
                    <AlignJustify className="w-4 h-4" /> ì–‘ìª½
                  </button>
                </div>
              </div>

              {/* ë¯¸ë¦¬ë³´ê¸° */}
              <div className="rounded-xl p-4 border" style={{ borderColor: themeStyle.border, backgroundColor: themeStyle.pageBg }}>
                <p className="text-[10px] mb-2" style={{ color: themeStyle.muted }}>ë¯¸ë¦¬ë³´ê¸°</p>
                <p style={{
                  fontFamily: FONTS[font].family,
                  fontSize: `${fontSize}px`,
                  lineHeight: lineHeight,
                  color: themeStyle.text,
                  letterSpacing: `${letterSpacing * 0.5}px`,
                  textAlign: textAlign,
                  textIndent: '1em',
                  wordBreak: 'keep-all',
                }}>
                  ê°€ë‚˜ë‹¤ë¼ë§ˆë°”ì‚¬ ì•„ìì°¨ì¹´íƒ€íŒŒí•˜. The quick brown fox jumps over the lazy dog. ì½ê¸° ì„¤ì •ì„ ë³€ê²½í•˜ë©´ ì´ í…ìŠ¤íŠ¸ì— ë°”ë¡œ ë°˜ì˜ë©ë‹ˆë‹¤.
                </p>
              </div>

            </div>
          </div>
        </>
      )}

      {/* â”â”â” í…ìŠ¤íŠ¸ ë³¸ë¬¸ â”â”â” */}
      <div ref={contentRef} className="flex-1 overflow-y-auto cursor-pointer" style={{ backgroundColor: themeStyle.bg }}
        onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd} onClick={handleClick}>
        <div style={{ maxWidth: currentMargin.maxW, margin: '0 auto' }} className={`${currentMargin.px} py-8`}>

          {unsupported && !isEpub && (
            <div className="mb-6 rounded-xl p-5 text-center" style={{
              backgroundColor: theme === 'dark' ? '#1e1e3a' : theme === 'sepia' ? '#f0e6cc' : '#f0f4ff',
              border: `1px solid ${theme === 'dark' ? '#2d2d50' : theme === 'sepia' ? '#d4c5a9' : '#d0d8f0'}`,
            }}>
              <div className="text-2xl mb-2">ğŸ“„</div>
              <p className="font-semibold mb-1" style={{ color: themeStyle.headingColor, fontSize: `${Math.round(fontSize * 0.9)}px` }}>
                ì´ ì½˜í…ì¸ ëŠ” ë¦¬í”Œë¡œìš° ëª¨ë“œë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
              </p>
              <p className="text-xs mb-4 leading-relaxed" style={{ color: themeStyle.muted }}>
                ìŠ¤ìº” ì´ë¯¸ì§€, ì¥ì‹ í°íŠ¸, ë²¡í„° ë³€í™˜ ë“±ìœ¼ë¡œ ì¸í•´{'\n'}
                í…ìŠ¤íŠ¸ë¥¼ ì •ìƒì ìœ¼ë¡œ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.{'\n'}
                PDF ë·°ì–´ ëª¨ë“œì—ì„œ ì›ë³¸ ê·¸ëŒ€ë¡œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
              </p>
              {onSwitchToPdf && (
                <button onClick={(e) => { e.stopPropagation(); onSwitchToPdf() }}
                  className="px-5 py-2.5 rounded-lg text-sm font-medium text-white transition-colors"
                  style={{ backgroundColor: '#3b82f6' }}>
                  PDF ë·°ì–´ë¡œ ì „í™˜
                </button>
              )}
            </div>
          )}

          {unsupported && isEpub && (
            <div className="mb-6 rounded-xl p-5 text-center" style={{
              backgroundColor: theme === 'dark' ? '#1e1e3a' : theme === 'sepia' ? '#f0e6cc' : '#f0f4ff',
              border: `1px solid ${theme === 'dark' ? '#2d2d50' : theme === 'sepia' ? '#d4c5a9' : '#d0d8f0'}`,
            }}>
              <div className="text-2xl mb-2">ğŸ“š</div>
              <p className="font-semibold mb-1" style={{ color: themeStyle.headingColor, fontSize: `${Math.round(fontSize * 0.9)}px` }}>
                EPUB ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
              </p>
              <p className="text-xs leading-relaxed" style={{ color: themeStyle.muted }}>
                ì´ EPUB íŒŒì¼ì˜ í…ìŠ¤íŠ¸ ë°ì´í„°ê°€ ì•„ì§ ì²˜ë¦¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.{'\n'}
                ë‹¤ì‹œ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì ì‹œ í›„ ì‹œë„í•´ ì£¼ì„¸ìš”.
              </p>
            </div>
          )}

          {isCurrentPageBroken && !unsupported && !isEpub && (
            <div className="mb-6 rounded-lg p-4 text-center" style={{
              backgroundColor: theme === 'dark' ? '#1e1e3a' : theme === 'sepia' ? '#f0e6cc' : '#f0f4ff',
              border: `1px solid ${theme === 'dark' ? '#2d2d50' : theme === 'sepia' ? '#d4c5a9' : '#d0d8f0'}`,
            }}>
              <p className="text-sm mb-2" style={{ color: themeStyle.muted }}>ì´ í˜ì´ì§€ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤</p>
              <p className="text-xs mb-3" style={{ color: themeStyle.muted }}>ì´ë¯¸ì§€, ì¥ì‹ í°íŠ¸ ë“±ì´ í¬í•¨ëœ í˜ì´ì§€ì…ë‹ˆë‹¤.</p>
              {onSwitchToPdf && (
                <button onClick={(e) => { e.stopPropagation(); onSwitchToPdf() }}
                  className="px-4 py-2 rounded-lg text-xs font-medium text-white transition-colors"
                  style={{ backgroundColor: '#3b82f6' }}>
                  PDF ë·°ì–´ë¡œ ì „í™˜
                </button>
              )}
            </div>
          )}

          <div>
            {(() => {
              const rawText = pageTexts.get(pageNumber) || ''
              // HTML ì½˜í…ì¸ ë©´ dangerouslySetInnerHTMLë¡œ ì§ì ‘ ë Œë”ë§
              if (rawText && isHtmlContent(rawText)) {
                return (
                  <div
                    className="reflow-html-content"
                    style={{
                      fontFamily: fontStyle.family,
                      fontSize: `${fontSize}px`,
                      lineHeight: lineHeight,
                      color: themeStyle.text,
                      wordBreak: 'keep-all',
                      overflowWrap: 'break-word',
                      letterSpacing: `${letterSpacing * 0.5}px`,
                      textAlign: textAlign,
                    }}
                    dangerouslySetInnerHTML={{ __html: `
                      <style>
                        .reflow-html-content h1 {
                          font-size: ${Math.round(fontSize * 1.6)}px;
                          font-weight: bold;
                          line-height: 1.3;
                          margin-top: 2.5em;
                          margin-bottom: 1em;
                          color: ${themeStyle.headingColor};
                          letter-spacing: ${letterSpacing * 0.5}px;
                        }
                        .reflow-html-content h2 {
                          font-size: ${Math.round(fontSize * 1.35)}px;
                          font-weight: bold;
                          line-height: 1.35;
                          margin-top: 2em;
                          margin-bottom: 0.75em;
                          color: ${themeStyle.headingColor};
                          letter-spacing: ${letterSpacing * 0.5}px;
                        }
                        .reflow-html-content h3 {
                          font-size: ${Math.round(fontSize * 1.15)}px;
                          font-weight: 600;
                          line-height: 1.4;
                          margin-top: 1.5em;
                          margin-bottom: 0.5em;
                          color: ${themeStyle.headingColor};
                          letter-spacing: ${letterSpacing * 0.5}px;
                        }
                        .reflow-html-content p {
                          margin-bottom: 1em;
                          text-indent: 1em;
                        }
                        .reflow-html-content figure {
                          text-align: center;
                          margin: 1.5em 0;
                        }
                        .reflow-html-content figure img {
                          max-width: 100%;
                          height: auto;
                          border-radius: 4px;
                        }
                        .reflow-html-content strong {
                          font-weight: bold;
                        }
                        .reflow-html-content em {
                          font-style: italic;
                        }
                        .reflow-html-content hr {
                          border: none;
                          border-top: 1px solid ${themeStyle.border};
                          margin: 1.5em 0;
                        }
                      </style>
                      ${rawText}
                    ` }}
                  />
                )
              }
              // ê¸°ì¡´ ë¸”ë¡ ì‹œìŠ¤í…œ (plain text, ì´ì „ ë°©ì‹ PDF í…ìŠ¤íŠ¸ í˜¸í™˜)
              return currentBlocks.length > 0 ? (
                currentBlocks.map((block, i) => renderBlock(block, i))
              ) : !isCurrentPageBroken && !unsupported ? (
                <p className="text-center py-8" style={{ color: themeStyle.muted }}>
                  (ì´ {pageLabel}ì— ì¶”ì¶œ ê°€ëŠ¥í•œ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤)
                </p>
              ) : null
            })()}
          </div>

          <div className="h-16" />
        </div>
      </div>

      {/* â”â”â” í•˜ë‹¨ ê³ ì • ë°”: ì§„í–‰ë¥  ìŠ¬ë¼ì´ë” + í˜ì´ì§€ ë„¤ë¹„ â”â”â” */}
      {numPages > 0 && (
        <div className="border-t px-4 py-2 max-w-lg mx-auto w-full" style={{ borderColor: themeStyle.border }}>
          <div className="flex items-center gap-3">
            <button onClick={(e) => { e.stopPropagation(); goToPrev() }} disabled={pageNumber <= 1}
              className="p-1 rounded transition-opacity disabled:opacity-30" style={{ color: themeStyle.muted }}>
              <ChevronLeft className="w-4 h-4" />
            </button>

            <div className="flex-1 relative group"
              onClick={(e) => {
                e.stopPropagation()
                const rect = (e.currentTarget as HTMLElement).getBoundingClientRect()
                const ratio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width))
                const targetPage = Math.max(1, Math.round(ratio * numPages))
                goToPage(targetPage)
              }}>
              <div className="h-1.5 rounded-full cursor-pointer" style={{ backgroundColor: themeStyle.border }}>
                <div className="h-full rounded-full transition-all duration-200"
                  style={{ width: `${numPages > 1 ? ((pageNumber - 1) / (numPages - 1)) * 100 : 0}%`, backgroundColor: '#3b82f6' }} />
              </div>
              <input type="range" min={1} max={numPages} value={pageNumber}
                onChange={(e) => { e.stopPropagation(); goToPage(Number(e.target.value)) }}
                onClick={(e) => e.stopPropagation()}
                className="absolute inset-0 w-full opacity-0 cursor-pointer"
                style={{ height: '24px', top: '-6px' }} />
            </div>

            <button onClick={(e) => { e.stopPropagation(); goToNext() }} disabled={pageNumber >= numPages}
              className="p-1 rounded transition-opacity disabled:opacity-30" style={{ color: themeStyle.muted }}>
              <ChevronRight className="w-4 h-4" />
            </button>
          </div>
          <div className="flex justify-between mt-1">
            <span className="text-[10px]" style={{ color: themeStyle.muted }}>{pageNumber} / {numPages} {pageLabel}</span>
            <span className="text-[10px]" style={{ color: themeStyle.muted }}>
              {(() => {
                if (numPages <= 1 || pageNumber <= 1 || elapsedSec < 10) return `${numPages > 1 ? Math.round(((pageNumber - 1) / (numPages - 1)) * 100) : 0}%`
                const pagesRead = pageNumber - 1
                const secPerPage = elapsedSec / pagesRead
                const pagesLeft = numPages - pageNumber
                const secLeft = Math.round(secPerPage * pagesLeft)
                const pct = numPages > 1 ? Math.round(((pageNumber - 1) / (numPages - 1)) * 100) : 0
                if (secLeft < 60) return `${pct}% Â· 1ë¶„ ë¯¸ë§Œ`
                const minLeft = Math.round(secLeft / 60)
                if (minLeft < 60) return `${pct}% Â· ì•½ ${minLeft}ë¶„ ë‚¨ìŒ`
                const hours = Math.floor(minLeft / 60)
                const mins = minLeft % 60
                return mins === 0 ? `${pct}% Â· ì•½ ${hours}ì‹œê°„ ë‚¨ìŒ` : `${pct}% Â· ì•½ ${hours}ì‹œê°„ ${mins}ë¶„ ë‚¨ìŒ`
              })()}
            </span>
          </div>
        </div>
      )}

    </div>
  )
}
